# Проект в рамках индивидуального плана развития сотрудника.

Проект описывает архитектуру взаимодействия продюсера и консьюмера.

Собрать и выгрузить в репозиторий образ консюмера.
```sh
sudo bash ./publish_consumer.sh
```

Собрать и выгрузить в репозиторий образ продюсера.
```sh
sudo bash ./publish_producer.sh
```
Собрать и выгрузить в репозиторий образ rabbit-mq (чаще всего это не нужно, но если есть кастомные правки, то надо выгрузить).
```sh
sudo bash ./publish_rabbit.sh
```
Если для запуска используется run.sh, то предварительно внутри скрипта поправить значение переменной среды PROJECT_ABSOLUTE_PATH на свое (абсолютный путь до папки проекта)

Запуск run.sh
```sh
sudo bash ./run.sh
```
## Описание проекта

Сервис-продюсер берет рандомное задание со статусом "ожидает обработки" из базы данных (в базе поля id задачния, text - текст для обработки, status - статус задания (ожидает обработки, отправлено на обработку, ошибка, успешно)) и ложит его в очередь Rabbit Mq.

Также сервис-консюмер постоянно слушает DLQ очередь и если там появляются сообщения, вытаскивает из них id и помечает в базе задания как ошибочные (меняет статус).

Смена статуса происходит по rest запросу к главному сервису-продюсеру, так как доступ к базе имеет только главный сервис.

Сервис-консюмер получает id задания для обработки из сообщения, затем производится имитация обработки, результатом будет либо успешная обработка или нет. Также реализован механизм Dead Letter Queue (DLQ) для неуспешно обработанных сообщений, неуспешные сообщения отправляются в очередь DLQ.

Предумотрен эдпоинт для создания задания

Все сервисы запакованы в docker-контейнеры и запускаются через docker-compose .

Содержимое проекта:
1) rabbit mq брокер - 1 контейнер
2) postgre sql - 1 контейнер
3) сервис-продюсер - 1 контейнер
4) сервис-консюмер - 2 контейнера

Доступные эндпоинты со стороны главного сервиса заданий

Создание задания:
```sh
POST /api/v1/create-task
Входные параметры:
json в body
Пример: {"text": "any text"}
```

Получение данных задания:
```sh
GET /api/v1/get-task-data
Входные параметры:
taskId - тип UUID
```

Изменение статуса задания:
```sh
PUT /api/v1/update-task-status
Входные параметры:
taskId - тип UUID
taskStatus - String
```
## Лицензия

MIT